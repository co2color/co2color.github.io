[{"title":"js如何存和传一个2^53次方以上的数据","date":"2023-12-13T15:12:45.000Z","url":"/2023/12/13/how-to-send-bigint-in-ajax/","tags":[["js","/tags/js/"]],"categories":[["js","/categories/js/"]],"content":"现在有这么一个需求：后端返回 list 给你，id 是一个 20 位数的 int 类型，在 js 里叫做 number 类型，你需要用 js 变量存储该数据，在编辑数据时候传入该 id，并且后端强校验必须传入数字类型。 坑 1：首先如果你不做任何处理直接去 getlist，比如如下代码： 这是因为 js 的 number 类型有个最大值（安全值），只能存储 2^53 内的数据，这个值是 9007199254740992，而我们的 12312312312312312312 很明显是大于这个安全值的。 那么该怎么办呢？可以使用 json-bigint 库（后面或许会考虑自己实现这么一个函数，先不纠结这个），这样拿到的数据就是字符串”12312312312312312312”，这样起码你能用变量存储这么一串数据了，虽然他目前变成了字符串： 至此，我们只是做到了 拿到数据并且正确存储数据，接下来是如何正确把该数据用 number 类型通过后端接口强校验，这里就涉及到坑 2 了： 我最开始的需求说了，后端 tm 强校验，必须传 number，不能传 string 的 id，你该怎么办？ 我们先来说 fetch 请求，一般来说，你传的 body 其实可以是一个 typeof object 类型，而不是一个序列化后的 string 类型： 回到需求，我们的 id 是 12312312312312312312，假设我们这样传： 嘿嘿，你是不是以为这样不行，这样失去精度之类的…..其实上面是可以的…..但是，但是，但是！上面的代码是写死的数据，并不是把这个 id 先赋值给了 js 变量，再传入该变量。这里是直接写死的。对于 fetch 来说，该请求的 body 最终会解析成一个序列化 json 字符串，所以如果你在代码里面写死一个很大的死数据，其实是没问题的。 但下面这种方式，就会失去精度，导致传入的 id 不对： 可以发现，你最终传入了一个错误的 id 给接口，这会导致你这次的操作失败。 那么该如何做，才能保证可以通过后端接口的强校验呢？（事实上，我个人认为这种长度的 id 本就不应该用 int，其次如果你后端真的用了 int，也应该允许前端传入字符串，不该做强校验。） 答案是转成 json 序列化再传。假设你已经用 json-bigint 库成功存储了这条数据： 此时我们肯定不能直接用 JSON.stringify(item)传给后端，这样是没办法通过他的校验的。 此时序列化后的 json 字符串是： 而我们要做的最关键的一步，就是把这个 str_item 变成： 发现区别了吗？value 里面的引号没有了，意味着从 string 变成 number 的。 但是这里不能用 JSON.parse 转对象后再 Number(id)，因为这个操作又会导致失去精度，所以我们只能全程操作字符串。 而这里的实现方式就各不相同了，比如你可以写个满足你规则的正则去替换掉里面的引号。 如果是复杂对象数组，我的建议是每层单独处理，比如该对象数组： 那么 str_list 应该是：’[{“pid”:”123123123123123123121”,”children”:[{“cid”:”123123123123123123122”},{“cid”:”123123123123123123123”}]}]’ 我们要做的是把每个 pid 和 children 里面的 cid 的 value 的引号去掉，那么可以这么写： 此时 str_list 就变成了：’[{“pid”:123123123123123123121,”children”:[{“cid”:123123123123123123122},{“cid”:123123123123123123123}]}]’ 这时候的数据是不能 JSON.parse 的，会失去精度，但是你可以直接把这段字符串传给接口，后端那边拿到你这段字符串，parse 后是能正确拿到该 id 的（拿不到的话 100%是后端技术问题） 所以总结一下，假如后端返回这条数据给你： 那么你需要用 json-bigint 库，拿到转成字符串且不丢失精度后的结果： 然后 JSON.stringify 变成：’[{“id”:”123123123123123123121”}]’然后把该结果的 value 的字符串删除，变成：’[{“id”:123123123123123123121}]’ 然后请求接口： 大功告成。"},{"title":"How to ask question","date":"2023-11-29T15:12:45.000Z","url":"/2023/11/29/how-to-ask-question/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":"以下皆为在公开群里的场景，不是一对一的场景。xxx 可以指工具&#x2F;框架&#x2F;语言&#x2F;bug 等等。可能会不定时更新Bad question Q： 有人用过 xxx 吗？有人了解过 xxx 吗？ 你想干什么？我们用没用过跟你有什么关系？你是说想询问该工具相关的问题？拜托，你为什么不直接问问题，而是选择发送一条浪费群友时间的消息？我不会选择帮助你。 Q： 我该如何入门&#x2F;学习 xxx？ 当然是选择找我按小时收费一对一辅导学习，难不成上博客&#x2F;github&#x2F;官方文档等等？这些可是需要你自己找的，还是当个伸手党老老实实找我付费学吧。欸你别走啊，我收得很便宜的…. Q： 请人遇到过 xxx （xxx 问题有人遇到过）吗 ? 就算有人遇到过&#x2F;解决过，人家大概率也不会愿意站出来，因为同一个问题可能有不同的产生方式，他的解决途径不一定适合你。而且你为什么不把你尝试过的解决方案简短地发出来，好让想尝试帮你解决问题的人预先排除方案呢？ Q： xxx(比如打包工具、语言环境)该如何配置啊？ 首先你打开配置，然后去配置你想配置的东西就好了~ 很简单吧。 Q： 我可以在 a 里面使用 b 吗？ 怎么，您是想让我帮你试试？行，付费的喔，咻~ 收款码发您了老板~ 未完待续"},{"title":"实现一个Web Router","date":"2023-11-13T14:46:29.000Z","url":"/2023/11/13/web-router/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":" 话不多说，用过 vue-router 就知道这篇在讲什么。 前端路由主要分为 hash 模式和 history 模式。 hashhash 模式使用 onhashchange 事件监听 hash 值变化： history详情见(mdn)[] 实践首先定义 BaseRouter: BaseRouter 接收路由数组，定义 render 函数用来渲染对应 html。 有了 base，我们就来挨个实现 hash 和 history。不管是 hash 还是 history，我们都要实现同样的几个方法：hander、getState、getUrl、push、replace、go 接下来先实现 hash 模式的函数： 然后是 historyRender： 然后我们定义一个路由数组： 然后在 index.js 中 init： 大功告成~"},{"title":"不喜欢使用element-plus的原因","date":"2023-10-09T14:45:26.000Z","url":"/2023/10/09/criticize-element-plus/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"vue2 时代，我的主力 ui 框架就是 elementUI，而步入新公司后，公司项目以 vue3+element-plus 为主，因此近来都是频繁地在使用 element-plus 这个 ui 框架。 我想说说为什么我自己的项目会选择使用 arco&#x2F;antd 而非 element-plus。 使用风格混乱 el-button:以按钮为例，plain\\round\\circle 分别定义按钮的形状，而我认为一个更好的方式是将其囊括为一个 prop，比如 acro 使用 shape&#x3D;”round||circle”这种方式来定义形状，我认为会更降低用户的心智负担。还有 icon 这个 prop，在 element-plus 中，想使用 icon+text 的话，它提供了 icon 这个 prop，可以传入@element-plus&#x2F;icons-vue 的图标。然而在我看来，这也是一个心智负担： 为什么这么说呢？太冗余了。设计者是想把其作为一个便捷功能植入 button 里，但实际上真的不应该面面俱到，就像 vue 被批 api 太多，不像在写 js 一样，我认为 icon 这种 prop 不应该存在，你可以提供一个#icon 的 slot 来处理，或者用户其实能在 content 里自行处理。你加个 icon 的 prop，还只能用你自己的 icons 组件，无形之中又加了一层心智负担。 el-radio 和 el-select:这俩组件十分让人迷惑困扰和厌恶。以下是 el-radio 的使用方式： 作为一个前端，一个很明显的事实是：如果要把该字段传给后端，100%是传一个 boolean 类型，而这个组件想设置该值的 prop 却叫做 label…如果是我，我会这样设置： 或者： 这样明显更直观。 而 el-select 组件就是这样的： 这样就没有心智负担了，value 代表值，label 则是显示给用户看的内容。而 arco 的 radio 则清爽很多： transfer穿梭框组件也是同样的问题，element 的用法是： 这里使用 key 其实没有太多问题，但作为一个同时间使用 transfer、select、radio 组件的人，一会儿 key，一会儿 value，一会儿 label，心智负担实在是太重了…. ps：关于 radio 使用 label 作为值这个事，近期(2023.10 月)element-plus core team 的人说：“收到建议哈，label 和 value 不统一确实会造成使用割裂，也确实是历史包袱的原因。当前大版本应该是不会做出改动了，如果有下个大版本，会优先修改这个问题。”"},{"title":"从Functional Programming的角度谈JavaScript中的闭包","date":"2023-09-17T14:05:41.000Z","url":"/2023/09/17/start_fp/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":" fp 即 函数式编程，本文都用 fp 代替 函数式编程。 作为一名 JavaScript 工程师，随着经验的增长，我发现 js 中的面向对象超令人困惑，比如原型和继承机制如何工作，比如 this 的使用，bind this 时遇到的各种困惑的 bug 等等。而 fp 会更顺手、更安全、更简单去调试，构建项目也更好维护。那么我就讲讲自己对 fp 的理解。 理解 fp在 fp 开发中，一切都要函数化，所以我们的思路就应该变成 考虑程序的输入输出数据流，而不是考虑对象如何交互或控制、一步步从上到下的实现。 比如，非 fp 打印字符串： 而 fp 会这么写： 你可能觉得，这不就是包裹了一层 func 吗？但函数式编程中，函数其实并不是指 JavaScript 中的 function 关键字定义个所谓的“方法”，而是数学上的函数，比如 y&#x3D;x、y&#x3D;sin(x)，相当于是一种映射关系。，并且只能有一个输入和一个输出。 所以你如果看到这里了，你会发现，fp 的核心点之一就是尽可能纯粹。何为纯粹呢？同一个输入永远对应相同的输出。所以像下面的代码就不是 fp： 我是一个有洁癖的人，不变的量只用 const，因此这里 name 使用 let 定义，你就应该能够猜到为什么这段代码不属于 fp 了：同一个输入，因为 name 可能会变化，因此其输出结果不一定相同。 再讲几点： 在 fp 中，你完全用不到 this 了，函数内的变量都是内部变量，直接使用即可。可以参考我这篇文章对 js 中 this 的吐槽。 webpack5 一大更新就是better tree-sharking，这是一个性能优化点，而你会发现，如果使用 fp，做 tree-sharking 就会变得更轻松，只要一个函数从头到尾都没有被调用过，就应该被剔除掉。 vue 中的 computed 一直强调不应该有副作用，而 fp 也如此，你不应该在函数内部去和外部的全局变量进行互动，函数功能完全应该独立，函数里面的表达式都是为了最终返回一个东西，不应该有其他任何行为。比如 js 中的 arr.slice 是不影响原数组的，而 splice 是会影响的，因此我们可以称 splice 是一个不纯洁的孩子。 闭包之前写过一篇闭包相关的文章，当时觉得自己讲得挺好的，但现在又有了新的认识。现有一个需求：实现 2 个数(即 2 个变量)相加。普通写法: 但这很明显不是 fp，因为上面的 add 函数有 2 个参数。 而用 fp 实现： 看这段代码，sum 其实属于 add 的某种“副本”，实现上需要有一块存储区域来记“sum 中的 a &#x3D; 1”这个状态，这个状态对外不可见，所以叫它闭包(Closure)。再通俗一点来说就是，因为 sum 要记住自己定义的时候 a 的值为 1，所以实现时，b &#x3D;&gt; a + b 和 a &#x3D; 1会捆绑在一起，这样的组合就是闭包。下面是一个 fp 中的闭包实际用例： 在这个例子中，闭包允许我们创建一个缓存对象 cache，并在不暴露给外部的情况下，持久地保存其状态。由于闭包的存在，每次调用 memoize 函数时，都会创建一个独立的 cache 对象，并将其保存在闭包中。每次调用 memoized 函数时，都会更新 cache 对象，并保留之前的结果。 所以，可以说 memoized 函数和 arg 是捆绑在一起的，每个 memoized 函数实例都与一个特定的 arg 值相关联。而 memoized 函数和 cache 也是捆绑在一起的，每个 memoized 函数实例都有自己的独立的 cache 对象。这种捆绑关系使得每个 memoized 函数实例都具有自己的状态，并且可以在闭包中持久地保存和访问这些状态，而这种状态对外是不可见的，是保存在 memoized 函数内部的，所以用“闭”和“包”这俩字的组合 「闭包」 来称呼，倒也是蛮形象的。"},{"title":"什么叫「组合优于继承」?","date":"2023-08-06T15:38:16.000Z","url":"/2023/08/06/start_composition/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":"现在我是一个项目经理，我有如下需求：一个动物园项目，有动物这个总的 Animal 类；动物分为鸟类和行走类；两种类型的动物都会吃饭；其中鸟类的动物会飞；而行走类动物只会用腿走路。 用继承来实现上面的需求： 很好，你的动物园有很多会飞的鸟，以及很多可爱的小狗狗，现在动物园一片和谐毫无 bug~ ……Two thousand years later…… 今天动物园来了一条大蟒蛇，该死的，这玩意不会 walk，因为它没有腿，它只会爬！ 但接手项目的人不愿意去翻看上古时代的 Animal 的源码，它觉得与蛇类似动物都继承自 Walker，没关系的，先继承了再说。 于是，在你们的动物园里，蛇变异成了一个“行走动物”，它明明没有腿却在凭空行走！你意识到，出 bug 了，于是回去看源码，发现前辈们居然给源头 Animal 类都添加了 walk 方法，你心想，这个前辈得多没见识，连蛇都没见过！然后第二天动物园又来了只鸵鸟…..该死的，鸵鸟不会飞！但由于你让鸵鸟继承了 Bird 类，结果鸵鸟也会凭空飞翔了… 该死的继承，害得你不得不回头看以前的代码，不然一不留神就写 bug 了。如果这是一个模拟动物园的游戏，那你这个游戏简直是奇观异景众生百态…. 为了修复这个 bug，你可以做如下改动： 上面是第一种做法。还有一种做法，是加 branch，即把 Bird 分为会飞的和不会飞的，那么鸵鸟继承自不会飞的鸟类就好了。 啊西….屎山代码的既视感扑面而来…. 继承是静态的，无法在运行时改变。后面增加的行为，你如果全部放在父类，那么这个操作虽然提高了复用性，但同时也会改变子类的行为，当然了，如果程序员对这个不稳定因素可控，那倒好说，你得保证新增加的父类的行为(功能、函数、方法，怎么叫都可以)不会被不该调用的子类实例(鸵鸟.fly() or snake.walk()等等)所调用；同时子类需要抛出错误，这增加了代码的复杂性，是我们不想看到的。另外，鸵鸟没有 fly，但它依然是鸟，所以 fly 方法一开始就不应该放到 Bird 类中。 那么，如果用组合来实现： 当你使用继承时，你发现一个 Bird 类不够用，于是就可能分化出 can fly 和 can’t fly 的两个 Bird，这样不断拆分后，是很难以维护的；而使用组合委托，你就不需要无限拆分了，这样，我们可以更灵活地组合不同的对象，而不需要受限于单一的继承关系。这符合了”组合优于继承”的设计原则。 上面的 demo 强行使用了 class，但我在这篇文章中很吐槽 class 了，所以，再给出一个非 class 的 demo。 如今随着 Be Your Dad 对日系三大妈的单方面虐杀，新能源汽车卖得越来越火热。因此，我们把大街上的私人汽车分为油车和电车，车都有启动和停止的功能，油车只能加油，纯电车只能充电，混动车可油可电。 给出组合示例： 可以发现，使用组合策略，你最好能“单一最小化”，比如在该例子中，汽车充电和汽车加油需要分开，不能合在一起，这样才能解耦最大化。 这个例子如果使用继承，那么充电车和混动车，都需要写一次 charge 方法，加油车和混动车都需要写一次 refuel 方法，这样代码复用率就降低了。 不过看到这个例子，vuer 可能会怒吼：“mixin 不是 vue 中的糟粕吗！你怎么还在用 mixin！” 我曰：vue2 中的 mixin 的坏处是把多个 mixin 都绑定到了一个 this 上面，导致来源不清晰、冲突等问题，然而跟该例子中的 mixin 是两件事，不要搞混了….该例子中每个 mixin 的内容自己控制，用 mixin 的对象都是各自独立的，要清楚这一点。 总结：继承想要好，就得一开始设计得好，父类最开始的时候就不能加太多的功能；而组合想要好，就挨个添加需要的功能，虽然一时半会代码量增多了，但是后面可以通过复用(比如该 demo 中 charge 和 refuelf 方法)来降低代码量。所以我认为组合的上限和下限都比继承高。"},{"title":"吐槽吐槽js中this、class","date":"2023-07-01T17:03:18.000Z","url":"/2023/07/02/this_class_js/","tags":[["js","/tags/js/"]],"categories":[["js","/categories/js/"]],"content":" 关于在JavaScript中使用this关键字和class关键字的一些吐槽 我觉得使用过js的程序员基本都不怎么喜欢this这个东西，目前我在工程中几乎已经不使用this了。我认为this就是缝合怪设计。 一个正常的前端程序员，几乎只有在需要面试时才会去重新记忆例如「多种指向」，比如寄生组合式继承等等内容。如果某人跟你battle这些，你可以直接反问他：“为什么老子学jvav py cpp php等等的语言都不需要考虑你说的这些莫名其妙的东西？这玩意不应该只跟class一起出现么，它怎么敢出现在普通函数中的啊？”又比如，关于js中的隐式转换，我觉得作为一个合格的前端工程师还是需要掌握的，但也仅此而已，这都是js的糟粕，学习这些东西，除了应对老旧工程项目和面试以外，没有任何意义。否则脱离了js你会发现你琢磨的这些东西都是在白费劲，是独一份。谁跟你谈隐式转换的原理，那希望你能停止和这个人的谈话，把时间拿去玩游戏睡觉都行。 按照我掌握的八卦，this的设计就是一个坑，是历史包袱导致的，大致可以概括为「产品经理要求的需求和程序员对于某些点的偏执」。到这里你应该把这件事当作类似于娱乐圈吃瓜的事情看待，js祖师爷要抄jvav，又要面向object而不是仅限于class，函数还得是一等公民，那咋办嘛….往函数里面丢this不就解决了….. 而我上面说，我几乎不使用this了，但在使用class时除外，只要你保证自己的代码是es6+语法的，那么其实并不会在class之外的地方用到this。 不过我一直觉得继承就是个shit，是编译技术落后的产物，以前的软件不怎么复杂，他们就觉得继承好像没什么，还挺方便…但后来软件越来越复杂，继承带来的强耦合太要命了，所以我其实一直都很不喜欢用class（但dom基本还是用的继承，so继承在js里始终是需要的）使用class还会有各种bind问题，一不注意你的this.xxx就变成undefined了。绝大部分大学在大一大二的时候都会开设比如c这种面向过程语言用来入门编程，然后再开jvav用来学习oop。我见过在vue2.x+ts的项目里的每个vue页面都使用class…..在我看来简直窒息….所以很多前端程序员在工作中，上来就喜欢写class….很多都是被jvav等等影响了。其实最基础的工厂函数就能搞定啊，比如项目封装网络请求，如果用oop class实现： 上面可以看出来在js中class的几个问题： bind关键字，需要使用this.getUser.bind(this)赋值给this.getUser，繁琐； 在class内部的getUser方法中使用baseUrl时需要用this去获取，繁琐； 需要使用new关键字定义httpClient这个实例，繁琐死了… 而使用工厂函数： 简洁多了。 而如若你就是想使用class，那也可以，因为class具有更高的声明性和静态可分析性，同时在现代引擎里也有更好的优化。另外，解决this的最好方法并不是bind，而是箭头函数。不推荐class并不是因为oop本身的问题，而是js中的this指向混乱的问题，得辩证看待。而我觉得继承这个设计不好，并不是js的问题，而是oop的问题……当年软件不复杂，硬件能力和编译技术都有限，用继承无可厚非，不能怪他们。可现在，起码2023年的内存完全是白菜价，我最近看16g ddr5才200块…加之编译技术也更强了，并且继承的心智负担实在是太重了，所以目前的新语言基本都不使用继承了。 可能未完待续。"},{"title":"工作中写过的一些“稀奇古怪”的工具函数","date":"2023-06-15T14:27:43.000Z","url":"/2023/06/15/usually_use_func_js/","tags":[["js","/tags/js/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":"1.asyncPoolasyncPool用来实现最大并发数同时执行异步请求： 2. isNumberjs中判断一个类型是否是number，有很多种方法，给出几种经典实现： 要注意，该方案会把字符串”123”判定为true。 3. compressImage2File(压缩图片) 4. getTextWidth(获取文字精确长度) 该font属性可以用如下方式获取： 5. unique(对象数组根据某个key去重) 比如： 6. chunk把一个数组arr按照指定的数组大小size分割成若干个数组块。 7. randomString 该函数经常用于vue中点击按钮新加一个项时，需要bind key避免dom更新混乱。因为你纯新建的时候，有时候一个list会没有唯一值，而用index当key显然是不可取的，那么就手动生成唯一key。第二个参数是个数组，为了避免生成的key在之前已经存在过（虽然这概率比你中彩票还小，但，严格点总不是坏事~） 8. getLadderArr给定大小a-b范围，给定一个等差额度，返回一个数组，长度为c，数组中的值为a-b范围内的等差值.比如给定[1,10]，等差额度为3， 就返回[1, 5.5, 10] 9. sortArrayOfObjects(对象数组排序函数，按指定键对对象数组进行排序) 10. calculateLength计算字符串长度，中文2个长度，英文1个长度 (可能)未完待续…."},{"title":"trojan +私有域名 配置vp埃斯","date":"2023-06-13T15:05:33.000Z","url":"/2023/06/13/vps_v2ray_config/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":" 这篇不知道会不会有什么风险，所以如果不懂标题是什么东西的人，还是别看了….. 你需要的东西 clash 一个vp埃斯和一个属于你的域名； ssl连接服务器后，输入脚本： 其中有很多种方案：VMESS，即最普通的V2ray服务器，没有伪装，也不是VLESS；VMESS+TCP+TLS，带伪装的V2ray，不能过CDN中转；VMESS+WS+TLS，即最通用的V2ray伪装方式，能过CDN中转，推荐使用；VLESS+TCP+TLS，最通用的VLESS版本，不能过CDN中转，但比VMESS+TCP+TLS方式性能更好；VLESS+WS+TLS，最通用V2ray伪装的VLESS脚本，能过CDN中转，推荐使用；VLESS+TCP+XTLS，目前最强悍的VLESS+XTLS组合，强力推荐使用（但是客户端支持没那么好）；trojan； 在这里我选择trojan，因为clash目前貌似还不支持vless协议…选择trojan后，继续按照cmd的信息往下走，输入你的域名和一个密码，回车，等待一段时间即可； 然后下载clash的模板配置文件,找到trogan相关的配置项，输入配置(你自己设置的配置，比如port不一定非要是443，取决于你自己设置的是什么)： 然后保存配置文件即可。 然后就是去clash，找到profiles-import-导入该文件，选择该config，然后就可以用了~ 另附trojan的脚本： "},{"title":"实现@vue/reactivity的computed","date":"2023-06-06T15:44:26.000Z","url":"/2023/06/06/vue3-reactivity-computed-storage/","tags":[["源码","/tags/%E6%BA%90%E7%A0%81/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":" 首先你至少需要具备中级JS水平，并且需要掌握vue3 effect的原理，比如其中的track、trigger等。如果你懂前者的话，我保证本篇看起来毫无压力~~ 首先给出Vue3 computed的最简使用方式： 从这个例子可以看出： computed是一个函数，返回一个新值； 该函数需要传递一个参数，这个参数是一个Function，即一个callback: 那么我们先init吧： 到这里你会发现，这和effect的实现一样，都是创建一个函数。而我们在effect函数内部可以看到，里面会new一个reactiveEffect这个类，功能都是写在这个类里面的，我们的computed也是用这种方式实现，所以，do起来，我们先定义一个ComputedRefImpl类： 一步步来，首先用get value来获取value： 在这里先提醒一句，咱先不关心computed的缓存性,先去想这里的响应性该如何实现。 我这里先说3点，根据这三点，就可以实现一个非缓存性的computed： computed的参数callback执行过程中，需要收集&#x2F;触发依赖； computed函数返回的值就是callback的值，如上面的age.value * 2； reactiveEffect的run方法返回的effect的”callback参数的返回值”； 综上，我们收集触发依赖其实都封装在reactiveEffect里面的，因此我们在computed里面就可以借助reactiveEffect来帮助我们收集和触发。这里我们把它写在ComputedRefImpl类的构造函数中： 现在，一个非缓存性的computed的内部就差不多了，接下来我们完善computed函数，该函数创建ComputedRefImpl类的实例并返回： 到这里，我们再捋一遍流程： 调用computed函数，创建ComputedRefImpl类实例并返回； 创建ComputedRefImpl实例时，执行构造函数，构造函数会创建一个reactiveEffect实例，然后将该实例赋值给ComputedRefImpl的私有属性_effect； 当计算属性调用value时，执行_effect.run()去获取computed的callback的返回值。 目前这个实现中，每次get value都需要重新执行callback函数然后再得到返回结果，你会发现，这是没有缓存性的。因此在此基础上，我们为computed增加缓存性。 要增加缓存性，我们就需要知道，何时get value该走缓存值直接return _value，何时该走_effect.run()赋值给_value再return。 思考一下…………………………………… 首先我们回到reactiveEffect来，我们看一下它的构造函数： 该构造函数接收两个参数，第一个是callback，而第二个！注意，第二个参数名叫做scheduler，中文可以叫做调度器。他的作用先不表，先继续看跟scheduler相关的代码，触发依赖的函数： 需要明确一点：当我们在effect函数中收集&#x2F;触发依赖时，收集的是fn这个用户传入的callback里面的reactive&#x2F;ref的依赖。而触发依赖时，默认我们会执行effect.run()，相当于把fn(也就是用户传入的callback)再执行一次，这其实就类似于vue3提供的watchEffect，比如该用法： 首先会打印1，然后age变化后，又会执行watchEffect的callback，所以age变化后就会打印2 回到触发依赖这里，刚刚说了，默认是走effect.run()，而如果我们传了scheduler，就会走scheduler而不走run，即这时候触发依赖后，不会执行传入的第一个参数的那个回调函数了，而是走scheduler这个自定义的地方。 那么我们就把scheduler当成另外一个callback，这样computed的callback的reactive&#x2F;ref触发依赖后，就不会走第一个参数的getter，而是走ComputedRefImpl构造函数的第二个callback参数了： 然后这里我们引入脏值检测这个概念，说白了就是额外定义一个boolean类型的变量去控制是否走缓存值。如果执行了scheduler这个callback，说明依赖更新(被改变)了，这时候就不应该走缓存，而是该重新去拿getter的最新值，因此现在代码应该这样改改： 初始状态，脏值为true，那么必走effect.run()去拿最新的getter的返回值，随后就把脏值变为false。而如若依赖没有被改变(没有触发依赖，其实就是指callback的reactive&#x2F;ref的值没有变),dirty就继续为false，那么这时候get value()就直接return _value，而不是去getter一次再返回，这样就相当于是拿的缓存值。而如若scheduler这个callback执行了，那么说明触发依赖了，那么就把dirty变为true。而计算属性是get value的时候才去算其值，所以此时去get value，就会去执行getter这个callback，去拿最新的返回值了。"},{"title":"koa+web前后端实现chatgpt从发送到接收数据","date":"2023-05-24T13:29:43.000Z","url":"/2023/05/24/easy-chatgpt/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":" 额….首先你自己得通过某种科学方法获得一个可用的openai-api-key 首先是接口实现，这里我使用koa。 方式1： axios, 非stream 下面是使用openai库的api来实现，首先引入： 方式2： openai npm package, 非stream 方式3： openai npm package, stream，得以让前端实现打字机效果(不停输出直到结束)这里我使用koa-sse-stream，先来看一个stream的简单实现： 那么结合我们的openai库自带的stream功能，来实现： 这样一个stream的请求就搞定了。 接下来看前端，前两个方式就是正常的请求，没有啥好说了的，能说的是上面的方式3，前端这边使用EventSource来实现： 现在后端这边算是完成了，但其实前端这边并没有完，因为你会发现EventSource这个东西只能是get请求，然而chatgpt支持长对话，也就是你需要传很长的数组，虽然get带参过去也能实现…..然而我算有点洁癖，我用get的接口只喜欢带单个id去查询单个数据，或者不带参数去查询所有数据，带一整个长对话content的数组，实在是受不了，因此，下面前端这边实现用fetch长连接+后端post sse实现： (额…..等我优化完毕再放代码)"},{"title":"最小编译器之traverser、transformer和codegen","date":"2023-03-28T17:08:16.000Z","url":"/2023/03/29/super-mini-compiler-two/","tags":[["js","/tags/js/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":" 本项目是the-super-tiny-compiler的 typescript 实现(下半部分) traverser前面讲了将字符串解析 token，然后转为 ast 树，那么接下来我们要对 ast 树进行遍历，实现一个 traverser 函数。该函数想做的事情是，深度优先遍历，以此能访问到整棵 ast 树的每个节点。注意，不要想太多，该函数仅仅是想让 Visitor 访问到每一个节点。对了，在实现 traverser 之前，我们必须理解一个设计模式——访问者模式。我上一篇博文就是为此而生的，因此这里不再赘述。同样地，我们先从测试入手，写一个能通过的测试 demo： 上面代码中，你只需要关注 ast 这个树，以及 visitor 这个访问者。我们用 callCounts 用来存储访问者所访问到的“东西”。 由此可见，我们的 traverser 需要两个参数：ast 树和 visitor 对象。在 traverser 函数中会执行 visitor 的各个 enter 和 exit。每个 visitor 都有 enter 和 exit 函数，从 test 中可以发现，每次执行 enter 或者 exit，callCounts 就会存储一个相关 NodeType。话不多说，先来实现： 上面代码是用深度优先遍历树的算法来遍历这颗 ast 树，第一次执行 traverNode(rootNode)时，没有 parent，因此 visitor.Program 的 enter 和 exit 函数的 parent 参数是不需要的，callCounts 第三个参数为空字符串即可。接着继续，深度优先，对子数组进行循环遍历，如果有子孙数组，就以此类推继续循环，也就是递归调用。最终会以深度优先的顺序把整棵 ast 树访问完。 transformer接下来是转换器（Transformer）的部分。我们的转换器接受上面的原始 ast 树，结合访问者，return 一个新的 AST： 解析：首先，创建一个空的新AST对象，类型为Program，body属性为空数组。接着，给原AST对象添加一个context属性，值为新AST的body属性，用于在遍历原AST时记录当前节点应该被添加到哪个父节点的context中。然后，使用traverser函数遍历原AST，对于每个CallExpression节点，创建一个新的expression对象，类型为CallExpression，callee属性为一个Identifier对象，name属性为节点的name属性，arguments属性为空数组。接着，将expression对象的context属性设置为节点的arguments属性，用于在遍历CallExpression的子节点时记录当前节点应该被添加到哪个父节点的context中。如果当前节点的父节点不是CallExpression，将expression对象包装在一个ExpressionStatement对象中。最后，将expression对象添加到父节点的context中。对于每个NumberLiteral节点，创建一个新的numberNode对象，类型为NumberLiteral，value属性为节点的value属性。将numberNode对象添加到父节点的context中。最后，返回新的AST对象。 这个函数其实就是对 CallExpression 节点类型进行了转换，将其变为了一个更复杂的表达式，包含了 callee 和 arguments 两个子节点。原始 AST 中的 CallExpression 节点只包含了一个 name 属性和一个 params 数组，而在新 AST 中，CallExpression 节点包含了一个 callee 属性和一个 arguments 数组，其中 callee 属性是一个 Identifier 节点，代表了函数名，arguments 数组中包含了对参数进行进一步处理后得到的新的 AST 节点。除此之外，还有一些细节上的变化，例如 AST 中的节点类型名称有所不同等。 你可能会疑惑，为什么当初不直接转成这个 ast，为何要多此一举？我的个人理解是，生成原始 AST 的过程是通过解析输入的代码字符串得到的，而转换过程则是通过对 AST 节点类型进行遍历，对每一种类型进行相应的处理，得到新的 AST。这种分离的设计方式，使得编译器的各个部分可以更加独立地进行开发和测试，同时也方便了对编译器进行扩展和修改。 codeGenerator现在我们进入最后一阶段：codeGenerator（代码生成器）。codeGenerator 函数将接受 transformer 的结果，也就是新的 Transformed AST，然后根据该 ast 转为新的字符串比如add(2, subtract(4, 2))： 简单解释： 在处理 Program 类型的节点时，它会递归处理节点的 body 属性中的所有节点，并将它们的代码字符串连接起来返回。 在处理 ExpressionStatement 类型的节点时，它会递归处理节点的 expression 属性，并在最后加上一个分号，返回生成的代码字符串。 在处理 NumberLiteral 类型的节点时，它会直接返回节点的值。 在处理 CallExpression 类型的节点时，它会生成一个函数调用的代码字符串，包括函数名和参数列表，并在其中递归调用每个参数节点的 codeGenerator 函数，最后将它们连接起来返回。 compilerFINALLY!!这个最简单，就是把上面的各个函数按顺序调用，实现 str code -&gt;ast-&gt; transformer ast-&gt; code str 总结调用 compiler： 此时经过 tokenizer 的 tokens 值为： 然后 parser 解析 tokens，得到的 ast 为： 然后transformer转换上面的ast，得到的transformedAst为： 最后调用codeGenerator，传入transformedAST，得到的结果为： 最终，我们实现了将(add 2 (subtract 4 2))转换为add(2, subtract(4, 2))的过程。 源码"},{"title":"设计模式之访问者模式","date":"2023-03-25T15:38:35.000Z","url":"/2023/03/25/js-vsitor-pattern/","tags":[["js","/tags/js/"]],"categories":[["设计模式","/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"访问者模式是一种行为设计模式，它可以将算法与对象结构分离。该模式允许你定义一个新的操作（访问者），而不改变被操作的对象结构。 举个例子：假设有一个 Document 对象，包含多个 Element 对象，如 Heading、Paragraph、Image 等。我们希望能够对这些元素进行不同的操作，例如计算它们的字符数、提取它们的文本内容等。我们可以使用访问者模式来实现这个功能。 首先，我们需要定义一个访问者对象，它包含不同的方法来处理不同类型的元素： 然后，我们需要定义一个抽象的元素对象，它包含一个 accept 方法，该方法接受一个访问者对象作为参数： 现在，我们可以定义具体的元素对象，例如 Heading、Paragraph 和 Image： 最后，我们可以使用访问者模式来对对象结构进行操作： 输出结果为： 这个例子说明了如何使用访问者模式来处理一个对象结构中的不同元素。它将算法与对象结构分离，并允许我们定义新的操作，而不改变被操作的对象结构。"},{"title":"最小编译器之tokenizer和parser","date":"2023-03-21T14:40:02.000Z","url":"/2023/03/21/super-mini-compiler-one/","tags":[["js","/tags/js/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":" 本项目是the-super-tiny-compiler的typescript实现(上半部分) 直接步入正题吧。现在有如下代码： 我们需要将这个字符串解析，转为parser[]数组。parser数组每个item的Token的类型： 遇到左右括号、操作符（加减乘除等）、数字时，就应该把该项push进数组。所以在code这段字符串中，除去空格忽略不计，转为的parser数组长度应该为9。先不看实现过程，我们可以通过肉眼看出，该code的转换结果应该为： 所以我们可以写好测试逻辑，这里用vitest： 接下来实现tokenizer。首先我们肯定需要循环去遍历整个字符串，这里我们使用while+指针的方式去遍历。实现思路： 创建数组：const tokens: Token[] = [] 遇到空格时，指针+1，continue，进行下一次循环； 遇到左右括号，创建一个Token类型的对象，把对象push到数组里，指针+1，continue； 遇到字符串或者数字，再来一个while循环（字符串&#x2F;数字各种独立实现）或者其实你可以有自己的实现方式，目的就是拿到这一段字符串&#x2F;数字，比如code字符串中的”add”字符串，遇到a字符的时候就while，然后遇到d继续，add后面是一个空格”add (“，所以遇到非字符串的时候，就结束该while循环。那么我们就来实现它吧： 接下来我们需要将tokens数组解析(parser)成ast树。所以这里需要实现一个parser函数。话不多说，代码并不复杂，先给出实现，再讲讲： 其实如果你的递归水平不错， 就不需要看下面的分析了，直接看上面代码就行了，下面的内容就是讲述这个递归思路的。对于这个测试用例tokens: 首先执行rootNode.body.push(walk())，我们把这个walk叫做walk1执行walk1，里面创建一个createCallExpressionNode(‘add’)，我们叫他AddNodeAddNode的params会push一个NumberNode(‘2’)，此时AddNode.params长度为1；然后继续while，继续while的话，因为紧接着就是左括号（token[3]），所以又会创建一个walk叫做walk2这个walk2的返回结果要被push到AddNode.params里面，也就是被push到NumberNode(‘2’)后面，使AddNode.params长度为2.因此我们要看看walk2到底返回什么东西后，才能push到AddNode.params里面，使得其长度为2:walk2中，会创建一个新的createCallExpressionNode(‘subtract’)，我们叫他SubtractNodeSubtractNode的params会push一个NumberNode(‘4’)和一个NumberNode(‘2’)所以walk2就返回SubtractNode(NumberNode(4),NumberNode(2))，把结果push到AddNode.params里面因此walk1就返回AddNode(NumberNode(2),SubtractNode(NumberNode(4),NumberNode(2)))，然后walk1就结束了表达式即：**( 2 + ( 4 - 2 ) )**然后解释一下最下面的while（可参考test中的’two callExpression’）: 这段代码是为了处理多个表达式的情况，比如：( ( 2 + 4 ) (3 + 5 ) )如果遇到了，就重复上面的过程，把结果push到rootNode.body里面，最后返回rootNode。"},{"title":"js继承","date":"2023-03-09T15:16:29.000Z","url":"/2023/03/09/js_inherit/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"寄生组合式继承: "},{"title":"老生常谈：手写js的call/apply和bind","date":"2023-03-06T16:10:30.000Z","url":"/2023/03/07/js_apply_bind/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":" 首先，对this没有最最基本的了解的同学，请阅读相关文章后再来此地探索。总而言之，this 永远指向最后调用它的那个对象 首先给出call的实现： 如果你不懂上面的context[key] &#x3D; this，看这里：在上面示例中，我们定义了一个person对象和一个introduce函数。然后，我们使用mycall函数来将person对象作为introduce函数的上下文对象，并传递一个greeting参数。最终，introduce函数被调用，并输出一条问候语和person对象的信息。重点：看我上面说的“谁调用mycall，this就是谁”，所以这里this的值实际上是指向调用 mycall这个函数的函数，也就是要修改上下文的那个函数，说白了就是指向introduce，也就是introduce这个函数被赋值给了context[key]，因此context[key]被调用，也就是introduce被调用啦。 再来点非人话：在 mycall 函数中，this 的值实际上是指向调用 mycall 函数的函数，也就是要修改上下文的那个函数。而在 fn.call(context, args) 中，fn 指的就是这个要修改上下文的函数，而 context 则是这个函数在执行时的上下文， args 则是要传递给这个函数的参数。我们可以将 mycall 函数想象成是把要修改上下文的函数拎出来执行，只不过这个函数在执行时的上下文被修改了。而 context[key] 则是将这个函数设置在新的上下文对象 context 上，key 则是要设置在上下文对象上的属性名。由于函数可以被当做普通的值进行赋值，因此我们可以将要修改上下文的函数设置在上下文对象上，从而改变这个函数在执行时的上下文。 再唠叨几句。上面使用了ES6的剩余参数（rest parameter）语法来接收任意数量的参数。在函数内部，我们先设置默认的上下文对象为window，这里使用了逻辑或运算符来实现。然后，我们使用Symbol()函数生成一个唯一的属性名，将当前函数作为上下文对象的一个属性值，并调用该函数。最后，我们删除这个属性并返回调用结果。这样，我们就实现了自己的mycall函数，它的作用和原生的call函数一样。同时，使用Symbol()函数生成一个唯一的属性名，并将其赋值给key常量。然后，我们将当前函数作为上下文对象的一个属性值，并调用该函数。最后，我们使用Reflect.deleteProperty方法删除该属性，这样就不会有任何副作用。我个人认为这个实现比掘金很多人的要好。他们有的人不用symbol实现，就context.func &#x3D; this，这样是完全错误完全不可接受的实现…..甚至还特么有生成8位随机数当作key….简直离了个大谱……. apply的实现apply就是把上面的mycall的第二个形参改成args，传数组进来，args本身就是一个数组，然后再在下面解构后就可以一个个传入函数中。 bind的实现 这个mybind方法与之前的mycall和myapply方法略有不同。它返回了一个新的函数，而不是直接调用原始函数。返回的新函数将在指定的上下文中调用原始函数，并使用提供的参数（即在mybind中传递的参数和调用新函数时传递的参数）。 使用mybind方法的示例： 在这个示例中，我们定义了一个名为person的对象，它具有一个greet方法。我们使用mybind方法创建了一个新函数greet，它将在person对象上下文中调用原始函数person.greet。我们还传递了一个额外的参数’Hello’，这意味着greet函数将始终使用’Hello’作为第一个参数调用person.greet。 我们在第一个调用中使用greet函数而不传递任何参数，这将导致person.greet方法以’Hello’和person作为参数调用，并输出”Hello, Alice!”。在第二个调用中，我们使用call方法将otherPerson对象作为greet函数的上下文，并期望输出”Hello, Bob!”。然而，由于我们使用了mybind方法绑定person对象作为上下文，greet函数将始终使用person作为上下文，而不管我们传递了什么样的参数。因此，第二个调用仍然输出”Hello, Alice!”。"},{"title":"实现@vue/reactivity的effect函数","date":"2023-02-21T17:09:09.000Z","url":"/2023/02/22/vue3-reactivity_effect/","tags":[["源码","/tags/%E6%BA%90%E7%A0%81/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":" 如果你已经熟练掌握vue3 effect的实现，那请不要再继续浪费1秒钟阅读本文章，大神请绕道。阅读本篇文章，你至少需要具备中级JS水平，并了解Vue3 composition Api以及ES6 Proxy的使用，最好还能再了解一点订阅发布这种设计模式。本篇文章仅对effect给出简约实现，去除了实际工程中的很多边界情况。但effect必须配合reactive&#x2F;ref使用，因此会顺便给出这二者的基本响应式实现。 首先来个最终用法： 首先定义响应式数据user，然后执行effect这个函数，该函数传入一个函数(后面简称函数cb，注意这是callback的简写哈。。)作为参数。接着执行age的赋值。我们都知道vue3中reactive的数据具有响应性，也就是说当你执行user.age = 20时，就会触发响应，重新执行cb()。那么一步步来，我们先不关注reactive，只看effect，当你执行effect()这个函数时，发生了什么？ 创建effect函数； effect函数里面new了一个Effect； new完后，cb会执行一次； cb执行过程中，收集cb函数语句的依赖，这里发现收集到了user.age这个依赖（人话：后续user.age改变时，用某种方式让cb再次执行） 1~2：创建effect函数，创建reactiveEffect类，然后new reactiveEffect： 3.new完后，我们需要让cb立马执行一次。可以发现，effect函数的形参fn被赋值给了reactiveEffect中的_fn，因此我们需要在reactiveEffect中写一个public方法，该方法执行this._fn()，我们把该方法叫做run： 然后在effect函数中调用： 至此，effect的cb会立即执行一次。 4.收集&#x2F;触发依赖；这里需要简单讲一下reactive。你首先肯定要写一个reactive函数，这个函数返回一个Proxy: 那么这里最重要的就是todo里面的内容了。我们在实际使用时，比如const person = reactive(&#123; age: 1 &#125;)，然后调用obj.age，此时就应该触发get，那么我们来实现get： 此时调用obj.age，就会触发这个get，返回res给obj.age。但是呢为了实现响应性，让effect的cb被触发，我们需要实现这个track函数，该函数应该放在effect模块中实现，在reactive中引入effect模块的track函数： 可以发现里面有activeEffect，这是effect模块中的全局变量，在外层定义。在reactiveEffect的run函数中，我们对它进行赋值： 这段可能不太好理解，我来点通俗易懂的解释：执行this._fn()的时候，视角就应该跑去这个_fn的内部，如果这个_fn内部有Proxy.get&#x2F;set被触发，就会track&#x2F;trigger；而如若执行get导致执行track，那么track里面的activeEffect是被赋值给了this的，于是就会执行后面的dep.add(activeEffect)。可能你已经猜到了，这么做就是为了存储activeEffect到dep中，以便后续set的时候执行dep_item.run()，dep数组的每个item都是一个reactiveEffect实例，拥有run方法，因此dep_item.run()就会执行effect中的cb。那么来实现set： 相应的，我们来实现trigger，trigger会执行effect的cb： 找到dep，然后执行所有dep的item(即effect)即可。 用demo总结：对于这段代码： 我的理解：1.首先执行effect()这个函数2.eff.run()执行上面effect()括号内的callback， 此时currentEffect就被赋值给了这个callback， 后面set的时候再触发该callback， 相当于又执行了effect()括号内的callback 3.执行callback的时候发现user.age被访问(被proxy劫持，触发get)了，于是执行track() 4.执行track()的时候发现currentEffect存在， 于是dep.add，即把callback添加到dep中，用于后面的trigger执行该callback5. 执行user.age &#x3D; 20的时候，触发set，于是执行trigger()6. 执行trigger()的时候，遍历dep，执行dep中的callback，即effect()括号内的callback，最终实现了类似vue的响应性 完整代码："},{"title":"实现vue3中的isRef/isReactive/isReadonly","date":"2023-02-13T17:05:56.000Z","url":"/2023/02/14/vue3-isRef-isReactive/","tags":[["源码","/tags/%E6%BA%90%E7%A0%81/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":" 读该文章之前，你需要先了解Proxy相关的知识。 最近读vue3源码，isRef使用了一个其实非常非常简单的办法。比如下面这段代码: 若你想判断obj是否是ref，其实很简单： 但isReactive和isReadonly不太一样。他们俩会先设定好一个map： 然后，如果你调用isReactive，就会去触发get： 接着，在Proxy get里面，单独对该key做一个判断，如果访问的是该key，就return true： 这里get返回true，因此isReactive返回true。（并且Proxy get后续代码不需要执行。也就是说，如果是访问了__v_isReactive这个字段，直接return true） 说到这里，再来一个computed的简易原理： computed里面的回调函数会返回一个值，然后在ComputedRefImpl类中get value返回该函数的值，最终，当你使用computedAge.value的时候就会去触发get，获取该callback的返回值。"},{"title":"js中forEach和for...of在使用async/await时的差异","date":"2022-11-17T14:59:49.000Z","url":"/2022/11/17/js-forof-forEach/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"项目中经常会用到js的forEach，那么它跟传统的for&#x2F;i++和for&#x2F;of有什么区别呢？ 先从一个简单的代码说起： 执行print，会发现 print over先被执行了。而写这段代码的人，本意大概率是想500ms后打印1，1000ms后打印2，1500ms后打印3，然后forEach结束，打印print over。 这里就涉及到forEach的内部原理了，阅读forEach源码可以发现，其内部是用callback方式去执行的，就类似于： 所以当你使用async&#x2F;await的时候，多个callback整体还是同步在执行，每个async作用的是callback内部函数的顺序（因此await的有效的，只是仅在callback内部有效，我看有一些帖子直接说forEach中await会无效这种说法不够严谨）。 而如果你使用for of，就不会有这种问题： for of 内部是通过迭代器去遍历的，因此会当作正常流去处理，每次循环，遇到await就等待其执行完，再进行下一次循环。您可以阅读for&#x2F;of源码一探究竟。"},{"title":"贪吃蛇（小游戏系列一）","date":"2022-09-09T18:05:39.000Z","url":"/2022/09/10/snake-game-one/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"贪吃蛇可以先看完整代码，粗略扫一遍先。这篇仅仅用于轻度解释逻辑。贪吃蛇最核心的就是蛇的移动：每次移动时，删除数组最后一个&amp;&amp;数组首插入一个，其实就是pop和unshift。一步一步来。### 定义基础数据创建canvas context对象，定义画布的宽度高度，以及每个格子的宽高SIZE。foodCanInBorder是用来判断生成的食物是否在最边上,在getRandomFoodLocation函数里写判断逻辑，return {x, y}（不重要，可以忽视）。initSnakeList是蛇的数组，这里需要注意一点，初始化x依次为30,31,31, 30是蛇头，那么这条蛇初始移动应该是从右向左，因此currentLocation默认为KeyA(WSAD,A代表左 )。t用来存计时器。初始化画布这个很简单，需要注意的是，dom需要在onMounted周期钩子内获取。渲染数据到canvas画布使用canvas的fillStyle和fillRect即可。判断逻辑判断是否吃到食物：如果吃到了食物，需要重置食物：蛇是否撞墙：撞墙后的逻辑，自由发挥：移动蛇首先需要写键盘监听，这个很简单：移动蛇，如果撞墙，游戏结束，清空t。否则按照上下左右去重新生成蛇头。如果吃到食物，就重置食物。如果没有吃到食物，则删除蛇数组的最后一个item（前面add了head item，这里delete last item，因此蛇总长度保持不变，游戏继续。）开始游戏开始之前先重置一下。当然，这里可以优化，我图省事。然后addKeyBoardWatch注册键盘监听。每次移动，先清空画布，然后render蛇和食物，然后移动蛇。不断重复这个过程。 "},{"title":"dependencies和devDendencies的区别","date":"2022-07-21T18:50:07.000Z","url":"/2022/07/22/dependencies-devDendencies-compare/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":"package.json门前有两座山，一个是dependencies，另一个(也)是devDendencies。 你可能会在cs某n这种博客看到类似如下解释： dependencies：生产环境必须要的依赖如vue lodash axios等等。 devDendencies：开发环境用的依赖，如eslint sass，不会被部署到生产环境。 而如果你看多了这些文章介绍，很可能会产生一种错误的认知：把axios放到devDendencies，不会被build进dist（实际上是会的，你在你的项目里想使用第三方发布的npm包axios，这种情况下，你放dependencies或者devDendencies都可以，没什么区别）。当你在项目中执行npm i的时候，dependencies和devDendencies都会被按照递归树进行安装。两者真正有区别的地方，我用一个实例来描述：现在你是一个伟大的开源npm包发布者，你想发布一个叫做”better-axios”的npm包，里面依赖nprogress这个包,用来做进度展示。同时，在这个包的开发过程中，你使用eslint这个包做代码规范检测。那么按照上述解释来安装，应该使用： 此时的package.json这俩兄弟长这样： 那么当你把这个”better-axios”发布后，其他用户使用npm i better-axios安装时，会只下载dependencies里面的nprogress，而不会下载devDependencies里面的eslint。对用户来说，你better-axios里的eslint是你自己开发环境中所依赖的包，用户在自己的项目中是不需要这个包的。所以你的node_moudles里多出来的树是better-axios和nprogress两个包。如果你把eslint放入dependencies里，用户就会install这个eslint。而对用户来说，eslint可能是不需要的。所以如果你是一个npm包发布者，你就一定要严格对待这俩兄弟。如果你只是开发项目，需要用第三方工具包，就不需要过于区别对待这俩兄弟，不管放哪，都会被build。但比较好的建议是，类似vite eslint放devDendencies，vue lodash dayjs等等放dependencies，虽然对项目打包结果没有任何影响，但这样勉强会规范点（吧）。"},{"title":"一个vue3的monorepo demo","date":"2022-07-04T15:50:03.000Z","url":"/2022/07/04/vue3-monorepo-pnpm/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"vue3-pnpm-monorepo-demo简介：monorepo简单来讲就是把多个项目放一个仓库里管理，这样你可以写公共组件、函数，这些组件函数可以给所有项目使用。你可以参考vue3的仓库，也是用的这种模式管理的。 我只想先跑项目该项目总共有三个子项目，如果你只想快速体验，那么依次运行：pnpm i -w（没有pnpm 的话先npm i -g pnpm）然后，三个子项目分别运行pnpm project1pnpm project2pnpm project3 开始如果你没有装pnpm，请先 npm i -g pnpm (node.js version&gt;14.9+)然后根目录 pnpm i -w运行某项目：pnpm xxx，如运行packages下的project1项目： pnpm project1新建项目流程(以新建项目projectA为例)：在packages文件夹下创建项目文件夹如projectA；cd projectA，然后npm init，得以创建package.json文件；改成如下内容： 如果有projectA项目特定的（仅projectA需要，其他项目不需要）包，则在根目录下用该命令： 切记，@project&#x2F;projectA这个字段必须和projectA&#x2F;paclage.json的name一致。 如需安装全局包（放在根目录package.json下，所有项目皆可使用）： (使用 -w 表示把包安装在 root 下，该包会放置在 root/node_modules 下。而如若要把包安装在某个项目中，则使用 -r 代替 -w。必须使用其中一个参数。） 运行和打包该项目：在根目录package.json script下添加：&quot;projectA&quot;: &quot;pnpm run -C packages/projectA dev&quot;和 &quot;build:projectA&quot;: &quot;pnpm run -C packages/projectA build&quot;。然后 pnpm projectA即可运行。 新建全局工具库&#x2F;函数&#x2F;资源方法：比如，你想在根目录创建别的工具文件夹如全局公共assets资源文件夹用来存放全部项目的公共图片资源，则： 根目录创建assets； cd assets，在assets下npm init，初始一个package.json，将name改为@xx&#x2F;assets； pnpm-workspace.yaml新增一行 - &#39;assets/**&#39; 根package.json的workspaces加上assets； cd ../，在根目录 pnpm i @xx/assets -w；至此，根package.json dependencies会多一个 “@xx&#x2F;assets”: “workspace:^x.x.x”，搞定~ pnpm官网：简介：   "},{"title":"手写promise(手写一的进阶)","date":"2022-06-16T14:34:35.000Z","url":"/2022/06/16/promise-write-thrid/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"手写系列一实现了一个基础版的Promise： 但该版本还有缺陷，比如不支持链式调用。想想链式调用的原理，一个then后面接一个then，那说明每个then都需要return new Promise()，这样下一个then才能正常使用。因此，重写then方法： 接下来需要实现resolvePromise函数： if (x &#x3D;&#x3D;&#x3D; promise2)的作用是：如果这个promise与返回值x相等，则需要reject这个类型错误（PromiseA+规范所写）。if ((typeof x &#x3D;&#x3D;&#x3D; ‘object’ &amp;&amp; x !&#x3D;&#x3D; null) || typeof x &#x3D;&#x3D;&#x3D; ‘function’)：如果x不是一个对象或者函数，那么为普通值直接resolve出去即可。接下来的判断是：如果then是一个函数则认为x是一个promise对象，然后调用它。并且附带2个参数（函数）处理resolve（参数y）和reject（参数r），如果r和y被多次调用或者对某个函数重复调用，第一次调用优先，其他忽略，因此指定一个全局变量called来控制调用。如果调用后抛出异常，这个异常可能在调用y或者r函数后造成也可能是在之前就抛出的 因此也需要使用called来控制是否抛出异常。而如果then不是一个函数或者对象，那么确定fulfilled状态resolve出去即可 至此，就可以正常进行链式调用了： 完整实现： "},{"title":"读vue-element-admin项目之所学","date":"2022-04-19T15:48:08.000Z","url":"/2022/04/19/study-by-vue-element-admin/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"项目源码：动态路由权限管理首先看src&#x2F;permission.js，这个是路由权限的核心代码。 解读：首先拿Cookies里的token值，如果有，说明进入时已经登录。这里分2种情况，1是你进入的是登录页面，那就跳转回首页，首页所有人都有这个路由权限，所以不需要判断；2是你进入的其他页面，那就需要判断你有没有将要进入的这个路由权限。这里通过const hasRoles &#x3D; store.getters.roles &amp;&amp; store.getters.roles.length &gt; 0去vuex里面拿权限。那么你要意识到，如果是页面刷新，这里vuex的数据都是清空了的，那hasRoles势必为flase。因此这里我们就分2种情况，1是用户是刷新页面或者点击登录按钮登录成功后跳转过来的（vuex数据都为空），那么就走else，去请求路由权限store.dispatch(‘permission&#x2F;generateRoutes’, roles)。这里想要hasRoles为真，就必须是从某一个路由跳到另外一个路由，比如你现在在&#x2F;a，你点击了跳转按钮到了&#x2F;b路由，这里触发router.beforeEach时，vuex里面就是有数据的（在第一次进来之前，先走这里的else，去dispatch permission&#x2F;generateRoutes拿到数据。然后到了刚才所说，从&#x2F;a到&#x2F;b，因此这里的vuex是必然有值的），这里的hasRoles的意思是判断用户是否通过getUserInfo接口去获取了自己的role。如果他通过接口去获取了，这个hasRoles必然为真。这里如果走else，也就是hasRoles为false的情况，那么继续分析，先通过userInfo接口拿该登录用户的roles，然后去拿该用户能访问的全部路由，然后addRouters添加。另外，next({ …to, replace: true })的意思是，如果 addRoutes 并未完成，路由守卫会一层一层的执行执行，直到 addRoutes 完成，找到对应的路由（在addRoutes()之后第一次访问被添加的路由会白屏，这是因为刚刚addRoutes()就立刻访问被添加的路由，然而此时addRoutes()没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。也就是说，这是用来确保addRoutes()时动态添加的路由已经被完全加载上去，参考：） 动态生成左侧菜单栏sidebar从&#x2F;src&#x2F;layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue可看出，v-for中菜单栏数组叫做permission_routes，通过computed+vuex mapGetters拿到。那么我们就要去看vuex这边的数据：&#x2F;src&#x2F;store&#x2F;modules&#x2F;permission.js，看到里面有个routers数组。那么这里数据从哪dispatch？固然是从src&#x2F;permission.js(区分开来，这是两个js，不同路径的哈)的const accessRoutes &#x3D; await store.dispatch(‘permission&#x2F;generateRoutes’, roles)而来。触发后，调用SET_ROUTES，然后执行state.routes &#x3D; constantRoutes.concat(routes)，将获取的路由数组concat到原路由数组的后面即可。你可以看到运行项目看看，项目中前面几个菜单如&#x2F;dashboard &#x2F;documentation&#x2F;index和&#x2F;guide&#x2F;index都是constantRoutes里面的，而&#x2F;permission后面的就是异步获取的。"},{"title":"easy vue3 hooks","date":"2022-04-02T11:32:10.000Z","url":"/2022/04/02/vue3-easyVuex/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"vuex4我还没用过，但社区都说不行不行。而vue3实现了一套响应性api可以直接用，那么试着自己来实现一个简单全局状态管理。 创建&#x2F;store&#x2F;useUserStore.js 使用： 读者可以自己试试，放两同级组件和，在Child1调用useLogin()，Child2的状态也会跟着改变。至此，用vue3自定义hooks实现了简单的全局数据共享和状态管理。 github： ps：vuex4不行，但pinia行（yyx说的）。个人认为我实现的这个，可以适用于很小型的项目。但是目前中型以上项目建议ts+pinia。我看了看pinia，摒弃了mutation，同步异步都放actions，我觉得很棒，不像vue2使用vuex那般，同步mutation，异步action，虽然这里的异步放action只是一个概念性的东西，里面其实怎么写都可以，只要确保同步必须用mutation就行了。这样做仅仅是为了方便devtools追踪状态，至于你写action请求ajax之类的导致异步竞态问题，那是使用者的问题，跟vuex无关哈哈哈哈(也是yyx说的，就是这么强势)。但总体而言。这样做肯定增加了使用者的心智负担。所以我个人认为pinia还是很棒棒的~pinia官网：更新：尤大3.20掘金直播里说pinia就是vuex5，所以放心大胆用吧~"},{"title":"谈js一道常见闭包问题","date":"2022-03-16T15:12:41.000Z","url":"/2022/03/16/js-closure/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"从一道常考js面试题说起相信90%js程序员都遇到过这个面试题： 如果你回答01234，那就抓紧学学闭包、变量作用域的知识吧。 答案：55555 原因：5个setTimeout都在排队等候，等for循环结束后才会执行。而var定义的i变量暴露给了全部的5个setTimeout，导致5个执行时拿到的都是i&#x3D;5。 刷过面试题的都知道，这里使用IIFE立即执行函数即可解决闭包造成的问题： 或者按值传递，每次都能拿到想要的i： 同时，绝大部分人都知道最最简单的方法是使用ES6的let代替var，这样每一轮的for都有自己的块级作用域，每个i只在循环的那一轮有效。 那么既然都使用ES6了，那就继续使用起来，promise+async&#x2F;await，模拟js没有的sleep()这个能忽悠客户打钱的方法吧： 这里建议大家都去申请一下Github Copilot，我本来想手动写完sleep方法，谁知我敲出 “const sleep”时候，copilot就自动给我补齐了我想要的。。简直牛逼 闭包是什么？借用mdn的描述： 一个函数和对其周围状态（ lexical environment，词法环境 ）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是 闭包 （ closure ）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 简单来说，以上面第一个代码为例，上级块级作用域内部变量，因为被下级作用域用到了，所以没有被释放。也就是顶层的var i被每个setTimeout用到了。这样就导致上级块级作用域内的变量，要等到下级作用域执行完后才释放。所以就可以用IIFE、let解决闭包造成的变量未释放问题。 再简单点说就是！：内部函数访问外部函数的变量，不仅可以访问，而且即使外部函数被返回被终结了，也依然可以访问。"},{"title":"防抖和节流","date":"2022-02-21T14:16:47.000Z","url":"/2022/02/21/js-debounce-throttle/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"如果你看不懂很多博客所说的关于防抖节流的概念，那就看我直接用例子描述：防抖例子：搜索框输入，你疯狂不停输入很多个字符时，只有等你停止输入了，才会执行查找方法。这里就不适合用节流，如果用节流，间隔3秒，那么你如果要10秒才能输入完你的问题，就会在3 6 9s的时候执行了总共三次的查找方法，有必要吗？没必要。这里你可以把防抖的时间设置为1s，那么1s内你在疯狂输入字符，就不会执行函数。而你1s没有输入的动静。就会执行方法。也就是说，防抖就是在疯狂进行操作时，最终只会触发最后一次操作的这么一个概念。 节流例子：鼠标左键点击一个按钮，3s执行一次按钮注册的方法。你每秒都在疯狂点击该按钮，但10秒只会在3 6 9s触发总共3次该方法。也就是说，节流就是在疯狂进行操作时，间隔你设置的时间去执行操作的这么一个概念(执行次数 &#x3D; 总时长 % 间隔时间，如总时长22秒，间隔时长3秒，那么会在3x7&#x3D;21秒内执行7次，第21+3&#x3D;24秒执行第8次，然后结束。) 最后再总结一次：防抖：玩王者的你疯狂点回城按钮想嘲讽对面（懒得数你点几次哦，反正最后一次才能回去）。节流：玩王者的你疯狂戳屏幕想释放技能（懒得数你点几次哦，反正下一次到了技能的间隔释放时间后我才执行）。"},{"title":"vue3中hooks的使用","date":"2022-02-09T15:12:44.000Z","url":"/2022/02/09/vue3-hooks-demo/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"提到vue3，谈得最多的就是Composition api，比起vue2的options api，官方给出了一张直观对比图：首先我想提一嘴，很多文章会说vue3是从类编程转变成了函数式编程，但官方文档说道： Despite an API style based on function composition, Composition API is NOT functional programming. Composition API is based on Vue’s mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability.虽然这套 API 的风格是基于函数的组合，但组合式 API 并不是函数式编程。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程更强调数据不可变。 我倒也不是想钻牛角尖，只是我个人也还是会和很多文章的作者观点一致，或者说最起码的，我觉得我写vue3确实在靠近函数式编程。（高中那会我私信问了一个知乎大佬，最适合入门的语言是什么，他说Haskell，但直到现在，我都还没能领悟函数式编程的精髓，因为一直在写oop语言。只知道函数式编程大概说的是，把各种功能细分到极致balabala） hooks其实我最初使用capi的时候，各种ref reactive和watch computed methods都定义到一堆，写得乱七八糟，甚至一度觉得，把ref、reactive当作vdata，其他定义的methods当作vmethods，那么我用options api不是更整齐么….直到我了解了hooks（如果你使用react，想必早就会了吧，尽情嘲笑我们vuer吧2333），我才发现，vue3是真TMD爽！ 笔者用element框架中的button按钮组件为例，来看看二者的差异，源码： vue2 el-button2的源码其实很简单，复杂度几乎全在于初始阶段的需求分析，只要把所有需求都罗列出来，挨个实现即可。代码层面就是vue2最基础的props父传子，computed去计算按钮的size和disabled，methods里面就一个click事件，然后emit回调给父组件响应此事件。 vue3 el-button代码太长就不放了，可以点链接进去看。粗看3的源码实现，你会发现，映入眼帘的就是hooks。我对hooks的理解：其本质是一个函数，封装你要使用的Composition api，类似于vue2.x中的Mixin，可以更好地抽离逻辑和复用代码。比如el-button中用到的useDisabled，就是一个复用性很强的例子。在vue2的el-button中，button的disabled状态是写在computed里的。而看vue3中的el-button实现： 其实上面的代码看着还是蛮费劲的（仅仅是想看看button的实现，翻出useDisabled的实现后，还得看import进来的MaybeRef、useProp等等是什么东西），但总而言之，这个useDisabled就是一个动态控制按钮是否可用的hooks。我尝试写一个最简单基础的hooks——useTitle，用来改变页面title： 使用方式： emmmm我觉得这个useTitle真没什么可说的，属于一看就豁然开朗的hooks初级入门demo。我没怎么学过react，就简单看过react官网的井字棋的实现。我认为vue3的ref就类似于React.useState，只是没有遵守hooks中的以use开头的命名规范（不过想想，这是我vue3的api，遵守个der啊）。hooks相比mixin，更能悉知复用代码的来源。我特别能体会被mixin支配过的恐惧，尤其是接盘一个陌生项目，每个vue页面引入三四个mixin.js，其中的data和methods完全看不出从哪来的。所以我觉得如果你使用了vue3，你一定要用上vue3.2+setup语法糖+ts可选+hooks。"},{"title":"手写promise(同步+异步)","date":"2022-01-14T13:43:41.000Z","url":"/2022/01/14/easy-async-promise/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"先直接上代码，再分析。 ps这篇文章讲怎么实现同步promise，所以你起码应该能会正常使用promise，懂得resolve和reject，懂得.then()会返回个什么东西，等等。 代码分析new Pms传入一个函数参数，再在constructor构造函数接收该参数，并且执行该函数executor()。执行该函数，相当于resolve(‘success resolve’)这里被执行（不知道各位理解得如何，刚开始我卡这里，不太能理解。后来想通了，new Pms这里是把整个函数当作参数传给了构造函数的，那么executor相当于就接收了这整个函数。那么executor()相当于就执行了这个函数。因此resolve(‘success resolve’)被执行），然后执行constructor里的resolve()，将状态从pending变为fulfilled，并将值传过来。reject同上，不再赘述。接着，看then部分。因为目前是同步代码，所以当执行then的时候，状态肯定不是pending了(要resolve或者reject后，更新状态，才执行then)，所以then函数就去判断2种状态，接受2个回调函数的参数，把值传过去，因此.then的第一个回调函数的参数res就能拿到resolve过来的字符串’success resolve’了。 思考异步怎么办？比如下面代码 执行完发现then的第一个函数参数并没有输出结果。这是因为then的时候，状态还是pending，没有触发条件。 好嘞，现在上异步代码。 如上。分析易得出两段代码不同点在于，多了两个数组，用来存放回调函数。流程：遇到.then，此时状态还是pending，因此执行pending的if逻辑，将该函数参数push到fulfilledTasks里等待执行。1s后resolve执行，再将fulfilledTasks里的函数执行。到此，实现了一个初步的promise功能。同时恭喜我们，学到了发布订阅这种设计模式。"},{"title":"canvas draw 画笔小玩具","date":"2022-01-10T13:32:43.000Z","url":"/2022/01/10/js-canvas-draw/","tags":[["js","/tags/js/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"使用canvas做一个兼容pc&#x2F;h5的画板。前置知识：canvas、事件捕获和冒泡、UI事件mouse&#x2F;touch。 首先创建一个画布 然后实现pc端各个mouse事件： 移动端touch事件： 当然了，这里需要判断是pc还是h5，可参考如下代码： 完整代码：："},{"title":"github-pr-step","date":"2021-12-11T11:54:42.000Z","url":"/2021/12/11/how-to-github-pr/","tags":[["综合","/tags/%E7%BB%BC%E5%90%88/"]],"categories":[["综合","/categories/%E7%BB%BC%E5%90%88/"]],"content":"阅读vue3文档时发现了文字重复的小问题，因此想提交pr。本文假设你的github username为grace,提交pr地址： 1）forkfork就不必说了，在star按钮左边。 2）clone到本地注意：fork后，应该git clone  而不是项目原来的地址。 3）与远程链接依次执行git remote -vgit remote add upstream  remote -v（查看） 4）创建&amp;切换分支假设你想要创建的分支名为xxname：git branch -b xxname 5）在此分支下正常修改代码，ctrl+s保存。然后提交：git add .git commit -m ‘xxx’git push origin xxname 6）最后一大步，去github提交pr。去也就是你fork的地址，点击tab下的pull request，点击绿色按钮 New pull request，注意最右边compare要选择你刚刚创建的分支的代码（从左往右依次是base repository,base,head repository,compare，就是这个compare），然后点击按钮Create pull request，写title+description即可提交一个完整pr。"}]